`include "constants.vams"
`include "disciplines.vams"

//------------------------------------------------------------------------------
// MESO2Y: Magnetoelectric Spin–Orbit (MESO) device compact behavioral model
//
// Aligned to equations described in:
//  - Nature: "Scalable energy-efficient magnetoelectric spin–orbit logic"
//  - Supplementary Information
//
// Xyce/ADMS stability choices:
//  - Dynamic state variables are represented as voltages on internal nodes and
//    integrated using ddt() (unit-capacitance style), rather than manual
//    $abstime-based updates.
//  - Very large leakage resistances are added to internal state nodes to avoid
//    DC singularities (floating internal nodes during DCOP).
//------------------------------------------------------------------------------

module MESO2Y(in, out, vdd, gate, gnd);
  inout in, out, vdd, gate, gnd;
  electrical in, out, vdd, gate, gnd;

  // Internal state nodes:
  //   V(nQ)  = Q_FE in Coulombs  (unit capacitor => I = dQ/dt)
  //   V(nmx) = m_x (dimensionless)
  //   V(nmy) = m_y (dimensionless)
  //   V(nmz) = m_z (dimensionless)
  electrical nQ, nmx, nmy, nmz;

  // -----------------------------
  // Physical constants
  // -----------------------------
  parameter real EPS0 = 8.854187817e-12;      // F/m
  parameter real MU0  = 4.0*`M_PI*1e-7;       // H/m
  parameter real KB   = 1.380649e-23;         // J/K

  // -----------------------------
  // Geometry / material parameters
  // -----------------------------
  parameter real F      = 1e-8;               // m (feature size)
  parameter real A_me   = 1.0e-16;            // m^2 (override if needed)
  parameter real t_me   = 5e-9;               // m

  // Multiferroic parameters
  parameter real eps_mf = 54.0;               // relative permittivity
  parameter real P_mf   = 0.003;                // C/m^2 (remanent polarization)
  parameter real E_mf   = 1.8e6;              // V/m (switching E-field)
  parameter real B_mf   = 0.03;               // Tesla (exchange bias at E_mf)

  // -----------------------------
  // Landau-Khalatnikov (LK) ferroelectric dynamics
  //   dP/dt = (1/rho0) * (E_app - dF/dP)
  //   dF/dP = 2*a1*P + 4*a11*P^3 + 6*a111*P^5
  //   Q_FE  = P*A_me
  // -----------------------------
  parameter real rho0   = 1000.0;             // damping (units consistent with this LK form)
  parameter real a1     = -1.48e8;
  parameter real a11    =  -3.06e7;
  parameter real a111   =  2.48e8;

  // -----------------------------
  // Nanomagnet parameters
  // -----------------------------
  parameter real Ms     = 8.0e5;              // A/m
  parameter real Ku     = 6.0e5;              // J/m^3
  parameter real alpha  = 0.01;               // Gilbert damping
  parameter real gamma  = 1.76e11;            // rad/(s*T)
  parameter real T_OP   = 300.0;              // K

  // Magnet dimensions
  parameter real w_m    = 2.0e-8;             // m
  parameter real l_m    = 2.0e-8;             // m
  parameter real t_fm   = 2.0e-9;             // m

  // Demagnetization factors (should sum to ~1)
  parameter real N_x    = 0.05;
  parameter real N_y    = 0.05;
  parameter real N_z    = 0.90;

  // -----------------------------
  // Spin–orbit conversion 
  // -----------------------------
  parameter real P_fm        = 0.7;
  parameter real lambda_IREE = 1.4e-8;        // m
  parameter real theta_SHE   = 0.5;
  parameter real lambda_sf   = 3.0e-9;        // m
  parameter real t_soc       = 4.0e-9;        // m
  parameter real R_isoc      = 4.0e3;         // Ohm

  // -----------------------------
  // Supply/access path
  // -----------------------------
  parameter real r_fm       = 3.0e-14;        // Ohm*m^2 
  parameter real Rs         = 4.0e3;          // Ohm 
  parameter real Lr         = 1.48e-4;        // Ohm*m 
  parameter real W_x        = 2.0e-9;         // m 

  // Gate control: gate LOW enables
  parameter real Vgate_th     = 0.5;          // V
  parameter real Vgate_smooth = 1e-3;         // V

  // Numerical helpers
  parameter real Rleak_state = 1.0e12;        // Ohm
  parameter real Rleak_Q     = 1.0e12;        // Ohm

  // Initial conditions
  parameter real Q_init  = 0.0;               // C (0 => use A_me*P_mf)
  parameter real mx_init = 0.0;
  parameter real my_init = 1.0;
  parameter real mz_init = 0.0;

  // Optional thermal noise (off by default)
  parameter integer enable_thermal_noise = 0;

  // Optional soft constraint to keep |m| ~ 1
  parameter real k_norm = 5e11;                // 1/s



 parameter real hbar=1.0545718e-34;
 parameter real elem_charge=1.60217663e-19;
 parameter real V_mag=5e-25;
 parameter real C_state=1.0e-15;


	real T_scale;
	real torque_x;
	real torque_y;
	real torque_z;
	real m_x_torque_x;
	real m_x_torque_z;
	real m_x_torque_y;
	real add_x;
	real add_y;
	real add_z;
	real Is_x;
	real Is_y;
	real Is_z;
	real M1;

  // -----------------------------
  // Internal reals (declared at module scope for ADMS friendliness)
  // -----------------------------
  real Qfe, mx, my, mz;
  real m_norm;

  real P, P2, P3, P5;
  real E_LK, E_app, dQ_dt;

  real E_r, B_me, H_me;

  real Hk;
  real H_ani_x, H_ani_y, H_ani_z;
  real H_demag_x, H_demag_y, H_demag_z;
  real H_th_x, H_th_y, H_th_z;
  real sigmaH;
  real H_eff_x, H_eff_y, H_eff_z;

  real mxH_x, mxH_y, mxH_z;
  real mDotH;
  real mxmH_x, mxmH_y, mxmH_z;
  real pref;
  real dmx_dt, dmy_dt, dmz_dt;
  real m2, err;

  real vg, sw;
  real R_on, R_fm, R_sum;
  real I_drive;

  real lambda_isoc;
  real I_s;
  real I_isoc;
  real m_dot_Is;

  analog begin

    // -----------------------------
    // Initialize internal states
    // -----------------------------
    @(initial_step) begin
      if (Q_init == 0.0) begin
        V(nQ,  gnd) <+ (A_me*P_mf);
      end else begin
        V(nQ,  gnd) <+ Q_init;
      end
      V(nmx, gnd) <+ mx_init;
      V(nmy, gnd) <+ my_init;
      V(nmz, gnd) <+ mz_init;
    end

    // -----------------------------
    // Read states
    // -----------------------------
    Qfe = V(nQ,  gnd);
    mx  = V(nmx, gnd);
    my  = V(nmy, gnd);
    mz  = V(nmz, gnd);

    // Normalize magnetization for field/torque computation
    m_norm = sqrt(mx*mx + my*my + mz*mz + 1.0e-30);

    mx = mx / m_norm;
    my = my / m_norm;
    mz = mz / m_norm;


    $display("Time=%g | raw Q_ME= %g, m = (%g, %g, %g) | |m|=%g", $abstime, Qfe, V(nmx,gnd)/m_norm, V(nmy,gnd)/m_norm, V(nmz,gnd)/m_norm, m_norm);
    // -----------------------------
    // Ferroelectric LK dynamics
    // -----------------------------
    P  = Qfe / A_me;
    P2 = P*P;
    P3 = P2*P;
    P5 = P3*P2;

    // Landau field term (V/m)
    E_LK  = (2.0*a1)*P + (4.0*a11)*P3 + (6.0*a111)*P5;

    // Applied E-field (V/m)
    E_app = V(in, gnd) / t_me;

    // LK ODE: dQ/dt = A/rho0 * (E_app - E_LK)
    dQ_dt = (A_me / rho0) * (E_app - E_LK);

    // Enforce: d/dt(Qfe) = dQ_dt
    I(nQ, gnd) <+ C_state*ddt(V(nQ,gnd)) - dQ_dt;
    //I(nQ, gnd) <+ V(nQ, gnd) / Rleak_Q;

    M1 = (A_me * EPS0 * eps_mf) / t_me;

    // Terminal current into ME is dQ/dt
    I(in, gnd) <+ M1*ddt(V(in,gnd)) + ddt(V(nQ, gnd));
    //I(in, gnd) <+ M1*ddt(V(in,gnd))+dQ_dt;

    // -----------------------------
    // Magnetoelectric effective field 
    // -----------------------------
    //E_r  = ( (Qfe/A_me) - P_mf ) / (EPS0 * eps_mf );
    E_r  = ( (Qfe/A_me) ) / (EPS0 * eps_mf );
    B_me = (B_mf / E_mf) * E_r;
    H_me = B_me / MU0;

    
    // -----------------------------
    // Supply/access transistor current 
    // -----------------------------
    vg = V(gate, gnd);
    sw = 0.5 * (1.0 - tanh( (vg - Vgate_th)/Vgate_smooth ));

    R_on  = Lr / (W_x + 1e-30);
    R_fm  = r_fm / (A_me + 1e-30);
    R_sum = Rs + R_on + R_fm;

    I_drive = sw * V(vdd, gnd) / (R_sum + 1e-30);

    I(vdd, gnd) <+ I_drive;



    // -----------------------------
    // Nanomagnet effective field
    // -----------------------------
    // Uniaxial anisotropy along +y (logic states ±y)
    Hk = (2.0*Ku) / (MU0 * Ms);
    H_ani_x = 0.0;
    //H_ani_x= H_me * MU0;
    H_ani_y = Hk * my;
    H_ani_z = 0.0;

    // Demag field
    H_demag_x = -Ms * N_x * mx;
    H_demag_y = -Ms * N_y * my;
    H_demag_z = -Ms * N_z * mz;


    // Thermal noise (optional)
    H_th_x = 0.0; H_th_y = 0.0; H_th_z = 0.0;
    //if (enable_thermal_noise != 0) begin
    //  sigmaH = sqrt( (2.0*alpha*KB*T_OP) / (MU0*Ms*(gamma)* (w_m*l_m*t_fm) + 1e-30) );
    //  H_th_x = white_noise(sigmaH*sigmaH, "Hth_x");
    //  H_th_y = white_noise(sigmaH*sigmaH, "Hth_y");
    //  H_th_z = white_noise(sigmaH*sigmaH, "Hth_z");
    //end

    // Total effective field
    H_eff_x = H_demag_x + H_ani_x + H_th_x;
    H_eff_y = H_demag_y + H_ani_y + H_me   + H_th_y;
    H_eff_z = H_demag_z + H_ani_z + H_th_z;

    // -----------------------------
    // LLG dynamics (Gilbert form expanded)
    // dm/dt = -(gamma*MU0/(1+alpha^2)) [ m×H + alpha*m×(m×H) ]
    // -----------------------------
    mxH_x = (my*H_eff_z - mz*H_eff_y);
    mxH_y = (mz*H_eff_x - mx*H_eff_z);
    mxH_z = (mx*H_eff_y - my*H_eff_x);

    mDotH = mx*H_eff_x + my*H_eff_y + mz*H_eff_z;

    // m × (m × H) = m(m·H) - H
    mxmH_x = mx*mDotH - H_eff_x;
    mxmH_y = my*mDotH - H_eff_y;
    mxmH_z = mz*mDotH - H_eff_z;

    pref = -(gamma*MU0) / (1.0 + alpha*alpha);

    dmx_dt = pref*( mxH_x - alpha*mxmH_x );
    dmy_dt = pref*( mxH_y - alpha*mxmH_y );
    dmz_dt = pref*( mxH_z - alpha*mxmH_z );

    // Optional soft normalization: dm/dt += k_norm*(1-|m|^2)*m
    if (k_norm != 0.0) begin
      m2  = (V(nmx,gnd)*V(nmx,gnd) + V(nmy,gnd)*V(nmy,gnd) + V(nmz,gnd)*V(nmz,gnd))/m_norm;
      err = 1.0 - m2;
      dmx_dt = dmx_dt + k_norm*err*(V(nmx,gnd)/m_norm);
      dmy_dt = dmy_dt + k_norm*err*(V(nmy,gnd)/m_norm);
      dmz_dt = dmz_dt + k_norm*err*(V(nmz,gnd)/m_norm);
    end

	Is_x = 0.0;
        Is_y = theta_SHE * I_drive;
        Is_z = 0.0;

        T_scale = (gamma * hbar) / (2 * elem_charge * Ms * V_mag);

        m_dot_Is = (mx * Is_x + my * Is_y + mz * Is_z);
        torque_x = T_scale * (Is_x - m_dot_Is * mx);
        torque_y = T_scale * (Is_y - m_dot_Is * my);
        torque_z = T_scale * (Is_z - m_dot_Is * mz);

	m_x_torque_x = (my * torque_z - mz * torque_y);
        m_x_torque_y = (mz * torque_x - mx * torque_z);
        m_x_torque_z = (mx * torque_y - my * torque_x);

	add_x=(torque_x - alpha * m_x_torque_x)/(1+alpha*alpha);
	add_y=(torque_y - alpha * m_x_torque_y)/(1+alpha*alpha);
	add_z=(torque_z - alpha * m_x_torque_z)/(1+alpha*alpha);

	dmz_dt = dmz_dt + add_z;
	dmx_dt = dmx_dt + add_x;
	dmy_dt = dmy_dt + add_y;

    // Integrate magnetization components
    I(nmx, gnd) <+ C_state*ddt(V(nmx, gnd)) - dmx_dt;
    I(nmy, gnd) <+ C_state*ddt(V(nmy, gnd)) - dmy_dt;
    I(nmz, gnd) <+ C_state*ddt(V(nmz, gnd)) - dmz_dt;

    I(nmx, gnd) <+ V(nmx, gnd) / Rleak_state;
    I(nmy, gnd) <+ V(nmy, gnd) / Rleak_state;
    I(nmz, gnd) <+ V(nmz, gnd) / Rleak_state;

    // -----------------------------
    // ISOC output current
    // -----------------------------
    lambda_isoc = lambda_IREE + theta_SHE*lambda_sf*tanh( t_soc/(2.0*lambda_sf + 1e-30) );
    I_s    = P_fm * I_drive;
    I_isoc = (lambda_isoc / (w_m + 1e-30)) * I_s * my;

    // Norton equivalent at OUT: current source in parallel with R_isoc
    I(out, gnd) <+ -I_isoc;
    I(out, gnd) <+  V(out, gnd) / (R_isoc + 1e-30);

  end
endmodule
